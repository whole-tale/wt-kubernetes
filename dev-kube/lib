#!/bin/bash

LOG=deployment.log

C_MAGENTA="\e[35m"
C_DEFAULT="\e[39m"
C_BRT_YELLOW="\e[93m"
C_BRT_GREEN="\e[92m"
C_BRT_RED="\e[91m"
C_BRT_GRAY="\e[37m"

set -o pipefail

logCommand() {
	echo $'\n\n' >> $LOG
	echo "$@" >> $LOG
	echo $'\n' >> $LOG
}

run() {
	local NAME OUT EC
	NAME="$1"
	shift
	logCommand "$@"
	OUT=`"$@" 2>&1 | tee -a $LOG` #`
	EC=$?
	
	if [ "$EC" != "0" ]; then
		emitn "failed" $C_BRT_RED
		emitn "Exit code: $EC" $C_BRT_YELLOW
		
		if [ "$OUT" != "" ]; then
			emitn "$OUT" $C_BRT_YELLOW
		fi
		
		exit 1
	fi
}

runc() {
	local NAME OUT EC
	NAME="$1"
	shift
	logCommand "$@"
	OUT=`eval "$@" 2>&1 | tee -a $LOG` #`
	EC=$?
	
	if [ "$EC" != "0" ]; then
		emitn "failed" $C_BRT_RED
		emitn "Exit code: $EC" $C_BRT_YELLOW
		
		if [ "$OUT" != "" ]; then
			emitn "$OUT" $C_BRT_YELLOW
		fi
		
		exit 1
	fi
}

runif() {
	if [ "$1" != "" ]; then
		shift
		run "$@"
	fi
}

mustBeSet() {
	local NAME VAL
	while [ "$1" != "" ]; do
		NAME=$1
		eval VAL=\$$NAME
		if [ "$VAL" == "" ]; then
			fail "Missing $1"
		fi
		shift
	done
}

fail() {
	emitn "$1" $C_BRT_RED 
	exit 1
}

# prepyaml <name> <file> [<dest>]
#
#     Copies <file>.[ty]aml to .<dest>.yaml or .<file>.yaml with
#     optional substitution of environment variables for .taml 
#     files.
#
#     <name>: A name for display purposes
#     <file>: The .yaml or .taml file name without the extension.
#             If a <file>.taml file exists, it will be processed
#             through envsubst and the output stored in either 
#             .<dest>.yaml if specified or in .<file>.yaml. If 
#             <file>.taml does not exist, <file>.yaml will be 
#             copied directly to .<dest>.yaml or .<file>.yaml as
#             above.
#     <dest>: An optional destination name without the .yaml 
#             extension. If not specified, .<file> will be used 
#             instead.
prepyaml() {
	local NAME="$1"
	local FILE="$2"
	local DEST="$3"
	
	if [ "$DEST" == "" ]; then
		DEST=".$FILE.yaml"
	else
		# add extension
		DEST="$DEST.yaml"
	fi
	
	if [ -f "$FILE.taml" ]; then
		runc "Processing $NAME template" "cat ./$FILE.taml | envsubst > tmp/$DEST"
	elif [ -f "${FILE}.yaml" ]; then
		runc "Processing $NAME template" "cp ./$FILE.yaml tmp/$DEST"
	else
		fail "Configuration file $FILE.yaml or $FILE.taml not found"
	fi
}

# delyaml <name>
#
#      Deletes .<name>.yaml unless $KEEP_TEMPS is set to 1.
#
delyaml() {
	local NAME="$1"
	if [ "$KEEP_TEMPS" != "1" ]; then
		runc "Deleting temporary file $NAME.yaml" rm "tmp/$NAME.yaml"
	fi
}

#
# contains <string> <cmd> [<args>]*
# 
#     Runs <cmd> [<args>] and checks if the output
#     contains <string>. If so, it returns 0 (true)
#     otherwise 1 (false). Gotta love this reverse
#     logic coming from exit codes.

contains() {
	local STR="$1"
	shift
	logCommand "$@"
	
	"$@" 2>&1 | tee -a $LOG | grep -q "$STR" 2>&1 >> $LOG
	if [ "${PIPESTATUS[2]}" == "0" ]; then
		return 0
	else
		return 1
	fi
}

# exists <type> <name>
# 
#     Checks if a kubernetes resource of type <type> and matching <name> 
#     exists. For example, "exists pod test" returns 1 if a pod containing
#     "test" in its name exists and 0 otherwise.
#
#     <type>: The type of kubernetes resource to check for
#     <name>: A string to look for in the existing list of resources of 
#             type <type>.
#
exists() {
	contains "$2" kubectl get "$1"
	return $?
}

shouldStart() {
	# Start service if either CONTINUE is not set or if 
	# CONTINUE is set and the service is not started
	if [ "$CONTINUE" == "1" ]; then
		echo -n "Checking if $1 should be started... "
		if exists pod "$1" ; then
			echo -e "${C_BRT_GREEN}no${C_DEFAULT}"
			return 1
		else
			echo -e "${C_BRT_YELLOW}yes${C_DEFAULT}"
			return 0
		fi
	else
		return 0
	fi
}

getArgs() {
	ARGS=()
	NARGS=1
	while [ "$1" != "" ]; do
		ARGS+=("--from-file" "$1")
		shift
		NARGS=$((NARGS + 1))
	done
}

createFromYaml() {
	local LABEL="$1"
	local SRC="$2"
	local DEST="$3"
	
	if [ "$DEST" == "" ]; then
		DEST=".$SRC"
	fi
	
	prepyaml "$SRC" "$SRC" "$DEST"
	run "Creating $LABEL" kubectl create -f "tmp/$DEST.yaml"
}

createConfigmap() {
	local NAME="$1"
	shift
	getArgs "$@"
	if exists configmap "$NAME" ; then
		run "Deleting old configmap $NAME" kubectl delete configmap "$NAME"
	fi
	run "Creating configmap $NAME" kubectl create configmap "$NAME" "${ARGS[@]}"
	run "Labeling configmap $NAME" kubectl label configmap "$NAME" "app=WholeTale"
}

createGenericSecret() {
	local NAME="$1"
	shift
	getArgs "$@"
	if exists secret generic "$NAME" ; then
		run "Deleting old secret $NAME" kubectl delete secret "$NAME"
	fi
	run "Creating secret $NAME" kubectl create secret generic "$NAME" "${ARGS[@]}"
	run "Labeling secret $NAME" kubectl label secret "$NAME" "app=WholeTale"
}

emit() {
	local MSG="$1"
	local COLOR="$2"
	
	echo -n -e "${COLOR}$MSG${C_DEFAULT}"
}

emitn() {
	local MSG="$1"
	local COLOR="$2"
	
	echo -e "${COLOR}$MSG${C_DEFAULT}"
}

deploy() {
	local NAME="$1"
	shift
	if ! exists service "$NAME" ; then
		if [ -f "service-$NAME.?aml" ]; then
			createFromYaml "service $NAME" "service-$NAME"
		fi
	fi
	if ! exists deployment "$NAME" ; then
		createFromYaml "deployment $NAME" "deployment-$NAME"
		emit "$NAME " $C_BRT_GREEN 
	else
		emit "$NAME " $C_BRT_YELLOW 
	fi
}

createVolumeClaim() {
	local NAME="$1"
	local SIZE="$2"
	export CLAIM_NAME="$NAME-volume-claim"
	export VOLUME_SIZE="$SIZE"
	export VOLUME_NAME="$NAME-volume"
	export SHORT_NAME="$NAME"
	
	if ! exists pvc "$CLAIM_NAME" ; then
		if [ -f "./volume-claim-$NAME.taml" ] || [ -f "./volume-claim-$NAME.yaml" ] ; then
			createFromYaml "volume claim $NAME" "volume-claim-$NAME"
		else
			createFromYaml "volume claim $NAME" "volume-claim-dynamic" ".volume-claim-$NAME"
		fi
		emit "$NAME " $C_BRT_GREEN 
	else
		emit "$NAME " $C_BRT_YELLOW 
	fi
}

createTLSSecret() {
	local NAME="$1"
	local KEY="$2"
	local CRT="$3"
	
	if ! exists secret "$NAME" || [ "$CONTINUE" == "0" ] ; then
		run "Creating $NAME" kubectl create secret tls "$NAME" "--key=$KEY" "--cert=$CRT"
		run "Labeling $NAME" kubectl label secret "$NAME" "app=WholeTale"
	fi

}

createSecretFromFile() {
	local NAME="$1"
	local FILE="$2"
	
	if ! exists secret "$NAME" || [ "$CONTINUE" == "0" ] ; then
		createFromYaml "secret $NAME" "$FILE"
	fi
}

checkDir() {
	local MYPATH=`realpath "$0"`
	export MY_ABS_DIR=`dirname "$MYPATH"`
	if [ ! -f "$MY_ABS_DIR/deploy.sh" ]; then
		fail "Please invoke deploy.sh from its own directory"
	fi
}